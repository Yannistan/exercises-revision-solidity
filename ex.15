 // SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
import './Adder.sol';
import './Suber.sol';
import './Multiplier.sol';
import './Divisor.sol';
import './CalcToken.sol';

contract Calculator {
    address _add;
    address private owner;
     mapping (address => uint256) private _balances;
    //FirstErc20 private token;
    Adder private adder;
    Suber private suber;
    Multiplier private multiplier;
    Divisor private divisor;
    
    constructor(address _adder, address _suber, address _multiplier, address _divisor) public {
        adder = Adder(_adder);
        suber = Suber(_suber);
        multiplier = Multiplier(_multiplier);
        divisor = Divisor(_divisor);
         _add = address(this);
        owner = msg.sender;
    }
    
    function add(uint256 nb1, uint256 nb2) public view returns(uint256) {
        return adder.add(nb1, nb2);
    }
    
    function sub(uint256 nb1, uint256 nb2) public view returns(uint256) {
        return suber.sub(nb1, nb2);
    }
    
    function mul(uint256 nb1, uint256 nb2) public view returns(uint256) {
        return multiplier.mul(nb1, nb2);
    }
    
    function div(uint256 nb1, uint256 nb2) public view returns(uint256) {
        return divisor.div(nb1, nb2);
    }
  function transfer(address _recipient, uint256 _amount) public returns (bool) {
    require(
      _balances[msg.sender] >= _amount,
      'ERC20: transfer amount exceeds balance'
    );
    _balances[msg.sender] -= _amount;
    _balances[_recipient] += _amount;
 //   emit Transfer(msg.sender, _recipient, _amount);
    return true;
  }
    
     modifier onlyOwner() {
    require(msg.sender == owner, 'Only owner can use this function');
    _;
  }
    
    function withdraw() public onlyOwner {
        transfer(msg.sender, _balances[_add]);
    }
    
}   
    

